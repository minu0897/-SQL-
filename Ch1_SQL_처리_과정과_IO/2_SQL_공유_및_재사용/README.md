
# SQL 공유 및 재사용

  

이 장에서는 소프트 파싱과 하드 파싱의 차이점을 설명한다.

  
  

### 1. 소프트 파싱 vs 하드 파싱

SQL파싱 -> 최적화 -> 로우 소스 생성 후 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간을 '라이브러리 캐시'라고 한다. 라이브러리 캐시는 SGA(System Global Area)구성요소다. SGA는 서버 프로세스와 백그라운드 프로세스가 공통으로 엑세스하는 데이터와 제어구조를 캐싱하는 메모리 공간이다.

![git_book_sql1](https://github.com/user-attachments/assets/02dea757-6bcf-4cf8-98d9-784dc8403a02)

  

SQL을 전달을 하면 DBMS는 그전에 파싱을해서 캐시에 남아있는지 확인을 한다.

있으면 바로 실행이 가능하다. 이것을 **소프트파싱**이라고한다.

하지만 캐시에 SQL을 찾았봤는데, 실패할 시 최적화 ->로우 소스생성 후 실행하는 것을 **하드파싱**이라 한다.

  
  

#### SQL 최적화 과정은 왜 하드(Hard)한가

우선 한가지 알아두어야할 것은 옵티마이저가 SQL을 최적화하는 작업은 생각보다 많은 일을 수행한다. 예를 들어 다섯개의 테이블을 조인하는 쿼리문에서 SQL 하나를 최적화하는데 무수히 많은 경우의 수가 존재한다. 조인 순서만 고려해도 5!(=120)정도이다. 여기에 조인방식, 인덱스 사용 유무, 인덱스종류 등 여러가지를 신경써야한다.

그 과정에서 옵티마이저는 아래와 같은 것을 참고한다.

* 테이블, 컬럼, 인덱스 구조에 관한 기본 정보

* 오브젝트 통계 : 테이블,인덱스,컬럼 통계

* 옵티마이저 관련 파라미터

  

무수히 많은 실행경로를 도출하고 짧은 순간에 딕셔너리와 통계정보를 읽어 효율적인 경로를 찾는 것은 쉬운 것이 아니다.

DB에서 대부분의 작업은 I/O작업에 집중되는 반면, **하드파싱**은 CPU를 많이 소비하는 몇 안 되는 작업 중 하나이다.

이렇게 어려운 작업을 거쳐 생성한 내부 프로시저를 한 번만 사용하고 버린다면 비효율적이다.

그래서 DBMS는 라이브러리 캐시를 이용해 이러한 작업을 여러 번 하지 않게 하고있다.

### 2. 바인드 변수의 중요성

사용자 정의 함수/프로시저, 트리거. 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 삭제하지않는 한 영구적 보관이 된다. 실행할 때 라이브러리 캐시에 적재되어 여러 사용자가 사용할 수 있도록한다.

  

SQL은 따로 이름이 없다. SQL자체에 텍스트가 이름이 된다. 딕셔너리에 저장도 안 한다. 처음 실행을 하면 최적화 과정을 거쳐 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재한 후 여러 사용자가 공유하면서 사용한다. 다만 SQL자체로 생성된 내부 프로시저는 캐시 공간이 부족하면 버려졌다가 다시 실행할 때 다시 똑같은 최적화 과정을 거쳐 캐시에 적재된다.

SQL은 자체가 이름이 되기에 텍스트 중 작은 부분만 수정하여도 새로운 객체가 탄생하는 구조다. 

Oracla 10g에서 생긴 SQL ID를 이름으로 사용해도 똑같다. 조금만 바꾸면 새로운 ID가 생성되는 구조이기 때문이다. 즉 SQL 전체 텍스트와 1대1 대응관계를 갖는다.

SQL을 만들고 실행하는 과정에서 일회성으로 SQL을 작성하다보니 무효화, 일회성 SQL이 무수히 많이 생성된다. 그것을 다 저장을 하면 그 SQL을 찾는 과정에서 더 많은 시간이 생성되고 공간 낭비를 유발한다. 그러다보니 오라클 SQL Server 같은 DBMS가 SQL을 영구적으로 저장하지 않는 쪽을 선택한다.

#### 공유 가능 SQL
라이브러리 캐시에서 SQL을 찾는 키는 SQL그 자체가 키가 된다. 의미적으로 같은 SQL일지라도, 대소문자만 다르다할지라도 다른 SQL로 관리가 된다. 실행할 때 각각 최적화를 진행하고 라이브러리 캐시에서 별도 공간을 사용한다.

#### 상황(쇼핑몰)
String SQLStmt = "select * from customer where login_id = '"+login_id + "'";
이하생략
이라는 코드가 있다 이 쇼핑몰에 100만명의 고객이 접속을 시도한다.
I/O사용률은 거의 발생하지 않지만 CPU 사용률은 급격히 올라갈 것이다. 이유는 100만명이 시도해서 발생하는 SQL 하드파싱 때문이다 . 라이브러리 캐시(V$SQL)을 조회해 보면, 100만개의 서로다른 ID로 SQL이 있는 것을 볼 수 있다. 고객이 로그인을 할 때 마다 내부 프로시저 한개를 만들어 라이브러리 캐시에 적재한 것 이다.
이것을 하나의 프로시저로 생성한 후 하나의 변수(login_id)로 실행가능하게 만들 었다면 라이브러리 캐시에는 하나의 프로시저만 확인할 수 있을 것이다.
이처럼 파라미터 Driven방식으로 SQL을 작성하는 방법도 있다. 바로  "바인드 변수"를 활용하는 것이다.

String SQLStmt = "select * from customer where login_id = ?";
PreparedStatement st = con.preoareStatement(SQLStmt);
st.setString(1,login_id);
이런식으로 한 후 라이브러리 캐시를 조회해보면, 
SELECT * from customer where LOGIN_ID = :1 으로 되어있을 것이다.
