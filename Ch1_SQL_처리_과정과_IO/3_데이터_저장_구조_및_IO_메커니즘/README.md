
# 데이터 저장 구조 및 I/O메커니즘
I/O튜닝이 곧 SQL튜닝이라고 해도 과언이 아니다.

이 장의 중요성은 높아보이고, 이해하기에는 어려워보인다.

### 1. SQL이 느린이유
SQL이 느린 이유의 대부분은 I/O때문이다. 구체적으로는 디스크 I/O때문이다.
이 책에서는 "IO를 잠(sleep)이라 설명을 한다. OS또는 IO서브시스템이 IO를 처리하는동안 잠을 자기 때문이다."이라고 적혀있다.
아마 운영체제에서 조금 배웠던 인터럽트와 관련된 내용같다.
프로세스가 일하지 않고 잠을 자는 이유는 여러가지가 있지만, I/O가 가장 대표적이고 절대 비중을 차지한다고 한다.

프로세스는 실행중인 프로그램이며, 아래와 같은 생명주기를 갖는다.
 new 이후 terminated전까지 ready와 running과 waiting을 반복한다. 
 (=생성 이후 종료전까지 준비와 실행과 대기를 반복한다.)
실행 중인 프로세스는 인터럽트에 의해 수시로 실행 준비 상태로 전환했다가 다시 실행 상태로 전환한다. 여러 프로세스가 하나의 CPU를 공유할 수 있지만, 특정 순간에는 하나의 프로세스만 CPU를 사용할 수 있기 때문에 이러한 메커니즘이 필요하다.

I/O Call 속도는 어떤 하드웨어냐에 따라 시간이 차이가 난다. 평균적으로 1초에 100블록을 읽는 방면 SSD로는 초당 500~1000블록을 읽게된다. 하지만 어떠한 SQL이 10000개의 블록을 읽어야한다면 좋은 하드웨어를 가진 시스템도 최소 10초는 기다려야한다. 즉 디스크에 IO가 SQL의 성능을 결정한다고봐도 된다. 우리는 더 좋은 하드웨어와 더 좋은 소프트웨어가 아닌 디스크 IO를 적게 사용하는 SQL을 작성하여 SQL의 성능을 올리는 방식을 사용한다. 

### 2. 데이터베이스 저장 구조
데이터를 저장하려면 먼저 테이블스페이스를 생성한다.
* 테이블 스페이스란? 세그먼트를 담는 컨테이너로서, 여러 개의 데이터파일(디스크 상의 물리적인 OS파일)로 구성된다.
* 세그먼트란? 테이블, 인덱스와 같이 데이터 저장공간이 필요한 오브젝트인다. 세그먼트는 여러 익스텐트로 구성된다. 인덱스도 하나의 세그먼트이고, 테이블 또는 인덱스가 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다. LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다.
* 익스텐드란? 공간을 확장하는 단위로서 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받는다. 익스텐드 안에는 연속된 블록들의 집합이 있다.

사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록이다. 참고로 DB2, SQL Server와 같은 DBMS는 블록 대신 페이지라는 용어를 사용한다.
한 익스텐드는 하나의 테이블이 독점한다. 즉 하나의 익스텐드 안에 담긴 블록은 모두 같은 테이블블록이다. (MS-SQL은 한 익스텐트를 여러 오브젝트가 사용가능)
현재까지 알아본 구조로는 테이블스페이스 세그먼트 익스텐트 블록이다. 여기에 데이터파일 간의 관계도 알아야한다.
세그먼트 공간이 부족해지면 테이블스페이스로부터 한개의 익스텐트를 추가로 할당받는다. 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지않을 가능성은 높다. 파일경합을 줄이기위해 DBMS는 가능한 여러 데이터파일로 분산해서 저장한다. 

#### DBA?
앞으로 종종 나올 용어이다. 정확히 짚고 넘어가려한다. 적어도 누군가 이 글을 본다면 자신있게 database administrator라고 말할 것이다.(본인이 그랬음.) 하지만 여기서 DBA란 Data Block Adress이다. 굉장히 하드웨어적 용어이다. 모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고윳값을 갖는다. 이 주소값을 DBA라 한다. 읽고 쓰는 단위가 블록이라 주소를 먼저 알아야한다. 인덱스를 이용해 테이블 레코드를 읽을 때는 index rowid를 이용한다. 

Rowid는 DBA+블록 내 순번 으로 구성된다. 이것을 이용해 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있게된다.
 
테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다. 익스텐트 맵을 이용하면 각 익스텐트의 첫 번째 DBA를 알 수 있다.

#### 정리
블록 : 데이터를 읽고 쓰는 단위
익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
세그먼트 : 데이터 저장공간이 필요한 오브젝트
테이블 스페이스 : 세그먼트를 담는 콘테이너
데이터파일 : 디스크 상의 물리적인 os 파일


### 3. 블록 단위 I/O
 DB에서 데이터를 읽는 단위는 중요하다. 적은 양의 데이터를 읽으면 시간이 오래걸릴 것이고, 너무 많은 양을 읽으면 쓸모없는 데이터까지 읽게되어 비효율적인 IO가 될 것이다. 그래서 읽는 단위는 중요하다. 우선 DB에서 읽는 단위는 **블록**이다. 
 DB에서 특정 레코드 한개를 읽고 싶어도 블록 단위로 통째로 읽는다. 
 테이블 뿐만 아니라 인덱스 또한 블록단위로 읽는다.
 
### 4. 시퀀셜 액세스 vs  랜덤 액세스
시퀀셜 액세스란?
논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. 
인덱스 리프블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어있다. 이 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다. 
(B+Tree에 리프노드가 연결된 방식이랑 비슷해보인다.)
테이블 블록간에는 서로 논리적인 연결고리를 갖고 있지 않다. 그렇다면 테이블은 어떻게 시퀀셜 액세스를 할까?
오라클 기준. 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵을 관리한다.(앞에서 설명한 내용임.) 읽어야할 익스텐트 목록을 익스텐트 맵에서 얻었다면 각 익스텐트의 첫번째 블록뒤에 연속해서 저장된 블록을 순서대로 읽는다. 이것이 Table Full Scan이다. 그리고 이것이  **테이블 시퀀셜 액세스**이다. 

랜덤 액세스란?
논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근 하는 방식이다. 

### 5. 논리적I/O vs 물리적I/O
앞에 말했듯이 SQL성능은 디스크I/O가 성능을 결정한다. 
앞서 SGA를 살펴보았는데, 이 중 중요한 요소가 **DB 버퍼캐시**이다. 
라이브러리 캐시 :SQL과 실행계획, DB 저장형 함수/프로시저를 캐싱한다.
DB 버퍼 캐시 : 데이터 캐시로 디스크에서 어렵게 읽은 데이터 블록을 캐싱해둔다.
DB 버퍼 캐시를 이용하면 I/O Call을 줄여 효율적인 데이터IO가 된다.
서버 프로세스와 데이터 파일 사이에서 IO가 일어나기 전 미리 DB 버퍼 캐시에 데이터가 있는지 탐색먼저한다. 있으면 IO Call이 일어나지 않고 데이터를 가져올 수 있다. 없다면 한번의 IO Call이 일어나고 그 블록을 DB버퍼캐시에 적재한다.

### 논리적I/O vs 물리적I/O 
지금까지 내용을 정리하면 데이터I/O가 일어나면 두 가지의 경우가 생긴다.
1. DB버퍼캐시에 데이터가 있으면 버퍼캐시에서 데이터를 가져온다.
2. DB버퍼캐시에 데이터가 없으면 디스크에서 데이터를 가져온다.

1번의 경우 버퍼캐시에서 데이터를 가져오면 전기적 신호로 데이터를 가져오며 빠른속도로 데이터를 가져올 수 있으면 이것을 **논리적I/O** 라한다.
2번의 경우 디스크에서 데이터를 가져오면 물리적 작용(액세스 Arm이용)을 통해 데이터를 가져온다. 굉장히 느리며, 이것을 **물리적 I/O**라 한다.

만약 SQL이 참조하는 테이블에 데이터를 입력하거나 삭제하지 않는 상황에서 조건절에 같은 변수 값을 입력하면 아무리 여러 번 실행해도 매번 읽는 블록 수는 같다. **SQL을 수행하면서 읽는 총 블록I/O가 논리적I/O이다. (같은 SQL로 인한 데이터는 버퍼캐시에 저장되기에)**

Direct Path Read(이방식은 6.2에서 자세히 설명)방식으로 읽는 경우를 제외하면 모든 블록은 DB버퍼캐시를 경유해서 읽는다. 따라서 논리적I/O횟수는 일반적으로 DB 버퍼캐시에서 블록을 읽는 횟수와 동일하다.(논리적I/O와 메모리I/O는 다른 개념이지만 수치는 동일하다.)
DB 버퍼캐시에 블록을 찾지못하면 디스크에 접근하여 블록을 읽는다. 이것이 물리적I/O 이다.
물리적I/O는 SQL이 참조하는 테이블에 데이터를 입력하거나 삭제하지 않는 상황에서도 값이 다르게 나온다. 그 이유는 실행할 때 마다 DB 버퍼캐시에 해당 테이블에 블록 점유율이 높아지기 때문이다. 시간이 지난 후 다시 실행하면 다시 물리적I/O는 늘어난다.

#### 블록I/O 적정량
딱 말하기는 어렵다. 검색범위, 조인하는 테이블 수, 대상 테이블 크기, 인덱스 구조 등에 의해 결정된다.
</br>
</br>
</br>
</br>

#### 버퍼캐시 히트율
아래는 전통적으로 가장 많이 사용하는 지표이다.
**BCHR(Buffer Cache Hit Ratio)**
BCHR = 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수 * 100
= (논리적 IO-물리적IO) / 논리적IO *100
= (1- 물리적IO / 논리적IO ) *100

BCHR은 물리적인 디스크IO를 기반하지 않고 곧바로 메로리에서 찾은 비율을 나타낸다.
온라인 트랜잭션의 경우 평균 99%의 히트율을 목표로한다.  수치가 높아보이지만 달성하기 어려운 수치는 아니다. 

BCHR이 약 99 라고가정하면
0.99 = 1 - 물리적IO / 논리적IO
물리적IO/논리적IO = 1/100 정도가 되야한다.
비율적으로 
**물리적IO : 논리적IO = 1 : 100**이다.
그리고 물리적IO/논리적IO의 수치는 낮을수록 좋아진다.
즉 성능을 위해선 물리적IO를 낮추거나 논리적IO의 수치를 높여야한다. 

물리적 IO를 낮추기 위해 수식을 보면
물리적IO = 논리적IO * (1 - BCHR/100) 이다. 여기서 중요한점은 BCHR은 시스템 상황에 따라 달라지는 통제 불가 변수이다. 그러므로 여기서 우리가 할 수 있는 물리적IO를 낮추는 방법은 논리적IO를 낮추는 방법이다.
* 논리적IO를 낮추면 BCHR이 낮아진다. 히트율이 낮아진다는건데, 이렇게 생각하면 수식을 이해하기 힘들고 BCHR을 하나의 상수라 생각하고 넘어가는 것이 편하게 읽힌다. BCHR = a라 가정하고 논리적IO를 낮춰도 BCHR은 a로 고정이라 생각하자

논리적IO줄이기
SQL을 튜닝을하여 읽는 총 블록 개수를 줄이면 된다. 논리적IO는 일정하게 발생하지만 SQL튜닝으로 충분히 낮출 수 있는 통제가 가능한 변수이다. 결국엔 **논리적IO를 줄임으로써 물리적IO를 줄이는 것**이 SQL튜닝이다.

요약을 하자면 BCHR에 우리가 할 수 있는 것은 논리적IO를 줄여서 물리적IO를 줄이는 방법 외엔 할 수 있는 것이 없다. 

BCHR을 실제로 구하려면 SQL 트레이스를 이용한 Call 통계 정보가 필요하다. Query와 Current 항목을 더한 값이 논리적IO이다. Disk 항목이 디스크에서 물리적으로 읽은 블록 개수다. 이 값들을 수식에 넣으면 BCHR을 구할 수 있다.

다만 BCHR이 SQL 성능을 좌우하지만, BCHR이 높다고 효율적인 SQL을 의미하지는 않는다. 같은 블록을 비효율적으로 반복해서 읽으면 BCHR이 높아진다.

아래 내용은 책에 나와있지는 않습니다. 
과거 메모리에 크기가 한정적일 때 BCHR은 중요한 지표였지만, 메모리의 크기가 커진 요즘에는 BCHR이 중요한 지표가 되지는 않는다고 한다. 다만 다른지표를 더 참조하는 것이지 BCHR가 주는 지표가 의미가 없지는 않는다.


### 6. Single Block I/O vs Multi Block I/O
캐시에서 찾지 못한 데이터 블록은 디스크를 통해 DB버퍼캐시로 적재하고서 읽는다. I/O Call을 할 때, 한 블록을 요청하기도 하고 여러블록씩 요청하기도 한다.
한번에 한블록씩 요청해서 메모리에 적재하는 방식을 'Single Block I/O '이라고한다. 한 번에 여러 블록씩 요청해서 메모리에 적재하는 것을 "Multi Block I/O"라고 한다.
인덱스를 이용할 때 기본적으로 인덱스와 테이블 블록 모두 Single Block I/O방식을 이용한다. 주로 소량의 데이터를 읽을 때 사용하는 것이 효율적이다.
- 인덱스 루트 블록을 읽을 때 
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

많은 데이터를 읽을 때는 Multi Block I/O가 효율적이다. 
그래서 인덱스를 이용하지 않고 테이블 전체를 스캔할 때 이 방식을 사용한다. 테이블 클 수록 Multi Block I/O 단위도 큰게 좋다. 보통의 OS는 1MB단위로 I/O를 수행한다. 

### 7. Table Full Scan vs Index Range Scan
Table Full Scan이란 테이블 전체를 스캔해서 읽는 방식과 Index Range Scan란 인덱스를 이용한 테이블 액세스 방식으로 두가지가 있다.  
Table Full Scan은 테이블에 속한 블록 전체를 읽어서 사용자가 원하는 데이터를 찾는 방식이다.
Index Range Scan이라하면 일정량을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾는 방식이다. 
+ ROWID:테이블 레코드가 디스크 상에 어디 저장됐는지를 가리키는 위치 정보이다.

Table Full Scan은 용어자체만 봐도 비효율적이다. 그리고 많은 쿼리 툴들이 실제로 해당 방법을 위험한 방법으로 빨간색 표시로 한다. 그러면 개발자들은 Table Full Scan 말고 다른 방식으로 유도한다. 하지만 이는 그렇게 많은 도움이 되지않는다.  실제로 인덱스 SQL 성능을 떨굴 수도있다. 한 번에 많은 데이터를 처리하는 집게용 SQL과 배치 프로그램이 특히 그렇다. 다 그런것은 아니지만 상당수가 Table Full Scan으로 유도하면 성능이 좋아진다. 조인을 포함한 SQL이면 조인 메소드로 해시 조인을 선택해주면된다.

성능이 느린 이유를 알려면, 우리는 Table , Index Scan의 본질을 봐야한다.
Table Full Scan의 경우에는 **시퀀셜 액세스과 Multiblock I/O**을 이용하여 디스크 블록을 가져온다. 한 블록에 속한 모든 레코드를 한 번에 읽어 들이고 , 캐시에서 못 찾으면 한 번의 IO Call을 통해 인접한 수십\~수백 개의 블록을 한꺼번에 IO하는 매커니즘이다. 이 방식을 이용하는 SQL은 스토리지 스캔 성능이 좋아지는 만큼 성능도 좋아진다. 다만 소량의 데이터를 조회하는데 수십\~수백개의 block을 가져와 데이터를 조회하면 수백만\~수천만 건의 데이터를 모두 스캔하게된다. 비효율적인 방법이된다. 이 처럼 큰 테이블에서 소량의 데이터를 조회할 때는 인덱스를 이용하는 것이 좋다.
인덱스의 경우 B+Tree를 이용하여 소량의 데이터를 찾는데 매우 적합하다.
+ B+Tree의 경우 본인(git에 정리하는 저를 말합니다.)은 학교 데이터베이스 수업시간에 배웠고, B+Tree에 대해 조금 공부를 하면 왜 좋은지 쉽게 이해할 수 있습니다. 또한 B+Tree는 DB에 한정된 것이 아닌 자료구조로서, OS에서도 쓰이는 자료구조입니다.
+ 
Index Range Scan의 경우는 **랜덤 액세스와 Single I/O**을 이용하여 디스크 블록을 읽는다. 캐시에서 블록을 못 찾으면 레코드 하나를 읽기 위해 매번 IO Call을 발생시킨다. 그렇다면 많은 데이터를 조회할 경우 하나의 데이터가 매번 IO Call을 일으키면 해당 SQL의 성능은 안 좋을 것이다. 따라서 많은 데이터를 읽을 떄는 Table Full Scan보다 불리하다. 