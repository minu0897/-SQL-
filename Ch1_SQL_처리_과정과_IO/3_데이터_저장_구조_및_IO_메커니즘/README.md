
# 데이터 저장 구조 및 I/O메커니즘
I/O튜닝이 곧 SQL튜닝이라고 해도 과언이 아니다.

이 장의 중요성은 높아보이고, 이해하기에는 어려워보인다.

### 1. SQL이 느린이유
SQL이 느린 이유의 대부분은 I/O때문이다. 구체적으로는 디스크 I/O때문이다.
이 책에서는 "IO를 잠(sleep)이라 설명을 한다. OS또는 IO서브시스템이 IO를 처리하는동안 잠을 자기 때문이다."이라고 적혀있다.
아마 운영체제에서 조금 배웠던 인터럽트와 관련된 내용같다.
프로세스가 일하지 않고 잠을 자는 이유는 여러가지가 있지만, I/O가 가장 대표적이고 절대 비중을 차지한다고 한다.

프로세스는 실행중인 프로그램이며, 아래와 같은 생명주기를 갖는다.
 new 이후 terminated전까지 ready와 running과 waiting을 반복한다. 
 (=생성 이후 종료전까지 준비와 실행과 대기를 반복한다.)
실행 중인 프로세스는 인터럽트에 의해 수시로 실행 준비 상태로 전환했다가 다시 실행 상태로 전환한다. 여러 프로세스가 하나의 CPU를 공유할 수 있지만, 특정 순간에는 하나의 프로세스만 CPU를 사용할 수 있기 때문에 이러한 메커니즘이 필요하다.

#### 중

그 과정에서 옵티마이저는 아래와 같은 것을 참고한다.

### 2. 데이터베이스 저장 구조
데이터를 저장하려면 먼저 테이블스페이스를 생성한다.
* 테이블 스페이스란? 세그먼트를 담는 컨테이너로서, 여러 개의 데이터파일(디스크 상의 물리적인 OS파일)로 구성된다.
* 세그먼트란? 테이블, 인덱스와 같이 데이터 저장공간이 필요한 오브젝트인다. 세그먼트는 여러 익스텐트로 구성된다. 인덱스도 하나의 세그먼트이고, 테이블 또는 인덱스가 파티션 구조라면 각 파티션이 하나의 세그먼트가 된다. LOB 컬럼은 그 자체가 하나의 세그먼트를 구성하므로 자신이 속한 테이블과 다른 별도 공간에 값을 저장한다.
* 익스텐드란? 공간을 확장하는 단위로서 테이블이나 인덱스에 데이터를 입력하다가 공간이 부족해지면 해당 오브젝트가 속한 테이블스페이스로부터 익스텐트를 추가로 할당받는다. 익스텐드 안에는 연속된 블록들의 집합이 있다.

사용자가 입력한 레코드를 실제로 저장하는 공간은 데이터 블록이다. 참고로 DB2, SQL Server와 같은 DBMS는 블록 대신 페이지라는 용어를 사용한다.
한 익스텐드는 하나의 테이블이 독점한다. 즉 하나의 익스텐드 안에 담긴 블록은 모두 같은 테이블블록이다. (MS-SQL은 한 익스텐트를 여러 오브젝트가 사용가능)
현재까지 알아본 구조로는 테이블스페이스 세그먼트 익스텐트 블록이다. 여기에 데이터파일 간의 관계도 알아야한다.
세그먼트 공간이 부족해지면 테이블스페이스로부터 한개의 익스텐트를 추가로 할당받는다. 세그먼트에 할당된 모든 익스텐트가 같은 데이터파일에 위치하지않을 가능성은 높다. 파일경합을 줄이기위해 DBMS는 가능한 여러 데이터파일로 분산해서 저장한다. 

#### DBA?
앞으로 종종 나올 용어이다. 정확히 짚고 넘어가려한다. 적어도 누군가 이 글을 본다면 자신있게 database administrator라고 말할 것이다.(본인이 그랬음.) 하지만 여기서 DBA란 Data Block Adress이다. 굉장히 하드웨어적 용어이다. 모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고윳값을 갖는다. 이 주소값을 DBA라 한다. 읽고 쓰는 단위가 블록이라 주소를 먼저 알아야한다. 인덱스를 이용해 테이블 레코드를 읽을 때는 index rowid를 이용한다. 

Rowid는 DBA+블록 내 순번 으로 구성된다. 이것을 이용해 읽어야 할 테이블 레코드가 저장된 DBA를 알 수 있게된다.
 
테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다. 익스텐트 맵을 이용하면 각 익스텐트의 첫 번째 DBA를 알 수 있다.

#### 정리
블록 : 데이터를 읽고 쓰는 단위
익스텐트 : 공간을 확장하는 단위, 연속된 블록 집합
세그먼트 : 데이터 저장공간이 필요한 오브젝트
테이블 스페이스 : 세그먼트를 담는 콘테이너
데이터파일 : 디스크 상의 물리적인 os 파일


### 3. 블록 단위 I/O
 DB에서 데이터를 읽는 단위는 중요하다. 적은 양의 데이터를 읽으면 시간이 오래걸릴 것이고, 너무 많은 양을 읽으면 쓸모없는 데이터까지 읽게되어 비효율적인 IO가 될 것이다. 그래서 읽는 단위는 중요하다. 우선 DB에서 읽는 단위는 **블록**이다. 
 DB에서 특정 레코드 한개를 읽고 싶어도 블록 단위로 통째로 읽는다. 
 테이블 뿐만 아니라 인덱스 또한 블록단위로 읽는다.
 
### 4. 시퀀셜 액세스 vs  랜덤 액세스
시퀀셜 액세스란?
논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. 
인덱스 리프블록은 앞뒤를 가리키는 주소값을 통해 논리적으로 서로 연결되어있다. 이 주소 값에 따라 앞 또는 뒤로 순차적으로 스캔하는 방식이 시퀀셜 액세스이다. 
(B+Tree에 리프노드가 연결된 방식이랑 비슷해보인다.)
테이블 블록간에는 서로 논리적인 연결고리를 갖고 있지 않다. 그렇다면 테이블은 어떻게 시퀀셜 액세스를 할까?
오라클 기준. 세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵을 관리한다.(앞에서 설명한 내용임.) 읽어야할 익스텐트 목록을 익스텐트 맵에서 얻었다면 각 익스텐트의 첫번째 블록뒤에 연속해서 저장된 블록을 순서대로 읽는다. 이것이 Table Full Scan이다. 그리고 이것이  **테이블 시퀀셜 액세스**이다. 

랜덤 액세스란?
논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근 하는 방식이다. 

### 5. 논리적I/O vs 물리적I/O
앞에 말했듯이 SQL성능은 디스크I/O가 성능을 결정한다. 
앞서 SGA를 살펴보았는데, 이 중 중요한 요소가 **DB 버퍼캐시**이다. 
라이브러리 캐시 :SQL과 실행계획, DB 저장형 함수/프로시저를 캐싱한다.
DB 버퍼 캐시 : 데이터 캐시로 디스크에서 어렵게 읽은 데이터 블록을 캐싱해둔다.
DB 버퍼 캐시를 이용하면 I/O Call을 줄여 효율적인 데이터IO가 된다.
서버 프로세스와 데이터 파일 사이에서 IO가 일어나기 전 미리 DB 버퍼 캐시에 데이터가 있는지 탐색먼저한다. 있으면 IO Call이 일어나지 않고 데이터를 가져올 수 있다. 없다면 한번의 IO Call이 일어나고 그 블록을 DB버퍼캐시에 적재한다.

### 논리적I/O vs 물리적I/O 
지금까지 내용을 정리하면 데이터I/O가 일어나면 두 가지의 경우가 생긴다.
1. DB버퍼캐시에 데이터가 있으면 버퍼캐시에서 데이터를 가져온다.
2. DB버퍼캐시에 데이터가 없으면 디스크에서 데이터를 가져온다.

1번의 경우 버퍼캐시에서 데이터를 가져오면 전기적 신호로 데이터를 가져오며 빠른속도로 데이터를 가져올 수 있으면 이것을 **논리적I/O** 라한다.
2번의 경우 디스크에서 데이터를 가져오면 물리적 작용(액세스 Arm이용)을 통해 데이터를 가져온다. 굉장히 느리며, 이것을 **물리적 I/O**라 한다.

	