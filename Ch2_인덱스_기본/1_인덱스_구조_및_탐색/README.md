
## 기본적 구조
인덱스의 기본구조를 알아야 인덱스 사용법과 튜닝을 말할 수 있다. 기본적 구조는 수평적 탐색과 수직적 탐색이 있다.

### 1. 미리 보는 인덱스 튜닝
#### 데이터를 찾는 두가지 방법
학교에서 홍길동을 찾는 방법은 두가지이다. 
- 모든 교실에 들어가서 홍길동을 찾는다. -> 동명이인이 많으면 유리하다.
- 교무실에서 학생명부를 보고 찾는다. -> 동명이인이 적으면 유리하다.

\+이 전제에서 홍길동이라는 이름을 가진 학생이 많은 것을 중점으로 보자
만약 이 학교에 이름을가지고 학생을 찾는 일이 많다면 학생의 이름,학년-반-번호 순으로 정렬해둔다면  찾는데 도움이 될 것이다. 이것이 인덱스다. 학년-반-번호가 ROWID에 해당한다.

DBMS에서도 두가지로 데이터를 찾는다.
- 테이블 전체 스캔
- 인덱스를 이욯한다.

#### 인덱스 튜닝의 두 가지 핵심요소	
OLTP(Online Transaction Processing)는 실시간으로 대량의 트랜잭션 데이터를 처리하기 위한 시스템이나 기술을 의미한다. 이러한 기술은 대용량 데이터내에서 소량의 데이터를 주로 검색하기에 인덱스 튜닝은 중요하다.

인덱스 튜닝의 핵심요소는 크게 두가지인다.
- 인덱스 스캔 과정에서 비효율을 줄이는 것이다.
- 테이블 액세스 횟수를 줄이는 것이다.

1. 인덱스 스캔 과정에서 비효율줄이기
만약 홍길동학생 중에 시력이 1\~2인 학생을 찾는다고 가정했을 때 만약 테이블이 이름,시력순으로 정렬이 되어있다면 홍길동 학생을 찾고 그 중에 시력이 1\~2인 학생을 찾으면된다. 효율적인 스캔이 가능해진다.
하지만 만약에 시력,이름순으로 정렬되어있다면, 시력을 기준으로 학생을 찾고 홍길동을 찾아야한다.
시력이 1\~2인 학생이 매우 많기에 많은 학생 중 홍길동을 찾아야하는 비효율이 발생한다. 이런식으로 인덱스에 대해 비효율을 줄이는 것을 **인덱스 스캔 효율화 튜닝**이라한다.
2. 테이블 액세스 횟수 줄이기
인덱스 스캔 후 테이블 레코드를 액세스할 때 **랜덤IO**방식을 사용한다. 이 랜덤IO를 줄이는 방식이 **랜덤 액세스 최소화 튜닝**이라한다.
이름순으로 정렬한 테이블(1번)과 시력순으로 정렬한 테이블(2번)이 있다고하자. 1번 테이블을 이용하여 홍길동을 찾았을 때 5명이 있다고하면 교실을 최대 5번정도 방문하면된다.
2번 테이블을 이용하여 시력이 1\~2인 학생이 50명정도 있다고하면 최대 50번 정도 방문해야한다. 이렇게 어떤 테이블을 사용하냐에 따라 교실방문 횟수(랜덤IO 횟수)가 달라진다.

두개 중 더 중요한 것은 **랜덤 액세스 최소화 튜닝**이다.

  
![](https://velog.velcdn.com/images/kimiwomno/post/21925f29-fba8-436b-b647-f53eab69e9f9/image.png)
위에 그림에서 인덱스 스캔은 학생명부를 찾는 과정이고, 학생명부에 없는 나머지 정보로 학생을 찾기위해 교실을 찾아가는 것을 줄이는 것이 훨씬 중요하다는 것이다.
이처럼 SQL 튜닝의 핵심은 **랜덤IO를 줄이는 것을 목표로해야한다.**



#### SQL 튜닝은 랜덤IO와의 전쟁
DB가 성능이 느린이유는 디스크 IO때문이다. 인덱스를 사용하는 OLTP라면 디스크IO중에서도 랜덤IO가 중요하다. DB에 많은 기능, 관련없이 보이는 기능도 랜덤 IO를 줄여 성능향상을 위해 개발된 것이 많다.

### 2. 인덱스 구조
인덱스란 대용량 테이블에서 데이터를 빠르게 액세스하기 위한 오브젝트이다. 책에 있는 색인같은 것이다. 만약 "메모리 소트"라는 단어를 책에서 찾으려면 색인없이는 책을 다 뒤져야하는 것이 일반적이다. 하지만 색인을 본다면 색인에 적힌 페이지만 확인하면된다. DB도 똑간다. 인덱스가 없다면 모든 데이터를 다 뒤질 것이다. 하지만 인덱스가 존재한다면 DB는 **일부만 읽고 멈출 수 있다.**

일부만 읽고 멈출 수 있다. 라는 문장을 잘 봐야한다. 일부만 읽어도 문제가 없다는 것은 일부만 읽었지만 그 일부에 내가 찾으려는 데이터가 다 존재한다는 뜻이다. 이처럼 일부(Range)만 읽는(Scan) 것을 Range Scan이라하며, 이것이 가능한 이유는 인덱스가 정렬되어 있기 때문이다. 일반적을 DBMS는 인덱스를 설정할 때 B*Tree 를 이용한다. 해당 구조는 B+Tree를 보면 쉽게 이해할 수 있으니 B+Tree를 공부하는걸 추천한다. 약간의 변형은 있지만 비슷한 구조를 가졌다.

하위블록은 Parent의 가리키는 값보다 작거나 같아야한다.  쉽게 보면 이진트리로 값을 이진해서 분류하는 것처럼 생각하면된다. 다만 BTree구조에선 무조건 2개로 분할하지는 않는다. 이진트리에서도 값을 찾을 땐 O(logN)으로 효율적인 검색이 된다. 이처럼 B*Tree를 이용하여 값을 효율적으로 찾게 도와준다. 리프블록에 값은 순서대로(왼쪽부터 오른쪽 끝까지)정렬되어있다. 원하는 리프 블록을 찾으면 각 레코드는 키 값 순으로 정렬되어있고 또한 테이블 레코드를 가진 주소값, 즉 **ROWID**를 가진다. 만약 인덱스 키 값이 같을 경우에는 ROWID로 정렬한다.(키,rowid 순으로 정렬) 

이러한 구조로 우리는 적은 탐색으로 소량의 데이터의 ROWID를 찾을 수 있다. ROWID를 얻기 위한 이유는 ROWID의 구조를 보면 알 수 있다.

ROWID = 데이터 블록 주소(DBA) + 로우 번호
DBA = 데이터 파일 번호 + 블록 번호
블록 번호 = 데이터파일 내에서 부여한 상대적 순번
로우 번호 = 블록 내 순번

**\* ROWID = 데이터 파일 번호 + 데이터파일 내에서 부여한 상대적 순번 + 블록 내 순번** 
즉 ROWID를 이용하면 테이블 레코드로 정확히 찾아갈 수 있다.

인덱스에는 수직적 탐색과 수평적 탐색이 존재한다. 두 가지를 알아야 인덱스 구조를 더 잘 이해할 수 있다.

### 3. 인덱스 수직적 탐색

### 4. 인덱스 수평적 탐색

### 5. 결합 인덱스 구조와 탐색