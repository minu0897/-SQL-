
## 기본적 구조
인덱스의 기본구조를 알아야 인덱스 사용법과 튜닝을 말할 수 있다. 기본적 구조는 수평적 탐색과 수직적 탐색이 있다.

### 1. 미리 보는 인덱스 튜닝
#### 데이터를 찾는 두가지 방법
학교에서 홍길동을 찾는 방법은 두가지이다. 
- 모든 교실에 들어가서 홍길동을 찾는다. -> 동명이인이 많으면 유리하다.
- 교무실에서 학생명부를 보고 찾는다. -> 동명이인이 적으면 유리하다.

\+이 전제에서 홍길동이라는 이름을 가진 학생이 많은 것을 중점으로 보자
만약 이 학교에 이름을가지고 학생을 찾는 일이 많다면 학생의 이름,학년-반-번호 순으로 정렬해둔다면  찾는데 도움이 될 것이다. 이것이 인덱스다. 학년-반-번호가 ROWID에 해당한다.

DBMS에서도 두가지로 데이터를 찾는다.
- 테이블 전체 스캔
- 인덱스를 이욯한다.

#### 인덱스 튜닝의 두 가지 핵심요소	
OLTP(Online Transaction Processing)는 실시간으로 대량의 트랜잭션 데이터를 처리하기 위한 시스템이나 기술을 의미한다. 이러한 기술은 대용량 데이터내에서 소량의 데이터를 주로 검색하기에 인덱스 튜닝은 중요하다.

인덱스 튜닝의 핵심요소는 크게 두가지인다.
- 인덱스 스캔 과정에서 비효율을 줄이는 것이다.
- 테이블 액세스 횟수를 줄이는 것이다.

1. 인덱스 스캔 과정에서 비효율줄이기
만약 홍길동학생 중에 시력이 1\~2인 학생을 찾는다고 가정했을 때 만약 테이블이 이름,시력순으로 정렬이 되어있다면 홍길동 학생을 찾고 그 중에 시력이 1\~2인 학생을 찾으면된다. 효율적인 스캔이 가능해진다.
하지만 만약에 시력,이름순으로 정렬되어있다면, 시력을 기준으로 학생을 찾고 홍길동을 찾아야한다.
시력이 1\~2인 학생이 매우 많기에 많은 학생 중 홍길동을 찾아야하는 비효율이 발생한다. 이런식으로 인덱스에 대해 비효율을 줄이는 것을 **인덱스 스캔 효율화 튜닝**이라한다.
2. 테이블 액세스 횟수 줄이기
인덱스 스캔 후 테이블 레코드를 액세스할 때 **랜덤IO**방식을 사용한다. 이 랜덤IO를 줄이는 방식이 **랜덤 액세스 최소화 튜닝**이라한다.
이름순으로 정렬한 테이블(1번)과 시력순으로 정렬한 테이블(2번)이 있다고하자. 1번 테이블을 이용하여 홍길동을 찾았을 때 5명이 있다고하면 교실을 최대 5번정도 방문하면된다.
2번 테이블을 이용하여 시력이 1\~2인 학생이 50명정도 있다고하면 최대 50번 정도 방문해야한다. 이렇게 어떤 테이블을 사용하냐에 따라 교실방문 횟수(랜덤IO 횟수)가 달라진다.

두개 중 더 중요한 것은 **랜덤 액세스 최소화 튜닝**이다.

  
![](https://velog.velcdn.com/images/kimiwomno/post/21925f29-fba8-436b-b647-f53eab69e9f9/image.png)
위에 그림에서 인덱스 스캔은 학생명부를 찾는 과정이고, 학생명부에 없는 나머지 정보로 학생을 찾기위해 교실을 찾아가는 것을 줄이는 것이 훨씬 중요하다는 것이다.
이처럼 SQL 튜닝의 핵심은 **랜덤IO를 줄이는 것을 목표로해야한다.**



#### SQL 튜닝은 랜덤IO와의 전쟁
DB가 성능이 느린이유는 디스크 IO때문이다. 인덱스를 사용하는 OLTP라면 디스크IO중에서도 랜덤IO가 중요하다. DB에 많은 기능, 관련없이 보이는 기능도 랜덤 IO를 줄여 성능향상을 위해 개발된 것이 많다.

### 2. 인덱스 구조
인덱스란 대용량 테이블에서 데이터를 빠르게 액세스하기 위한 오브젝트이다. 책에 있는 색인같은 것이다. 만약 "메모리 소트"라는 단어를 책에서 찾으려면 색인없이는 책을 다 뒤져야하는 것이 일반적이다. 하지만 색인을 본다면 색인에 적힌 페이지만 확인하면된다. DB도 똑간다. 인덱스가 없다면 모든 데이터를 다 뒤질 것이다. 하지만 인덱스가 존재한다면 DB는 **일부만 읽고 멈출 수 있다.**

일부만 읽고 멈출 수 있다. 라는 문장을 잘 봐야한다. 일부만 읽어도 문제가 없다는 것은 일부만 읽었지만 그 일부에 내가 찾으려는 데이터가 다 존재한다는 뜻이다. 이처럼 일부(Range)만 읽는(Scan) 것을 Range Scan이라하며, 이것이 가능한 이유는 인덱스가 정렬되어 있기 때문이다. 일반적을 DBMS는 인덱스를 설정할 때 B*Tree 를 이용한다. 해당 구조는 B+Tree를 보면 쉽게 이해할 수 있으니 B+Tree를 공부하는걸 추천한다. 약간의 변형은 있지만 비슷한 구조를 가졌다.

하위블록은 Parent의 가리키는 값보다 작거나 같아야한다.  쉽게 보면 이진트리로 값을 이진해서 분류하는 것처럼 생각하면된다. 다만 BTree구조에선 무조건 2개로 분할하지는 않는다. 이진트리에서도 값을 찾을 땐 O(logN)으로 효율적인 검색이 된다. 이처럼 B*Tree를 이용하여 값을 효율적으로 찾게 도와준다. 리프블록에 값은 순서대로(왼쪽부터 오른쪽 끝까지)정렬되어있다. 원하는 리프 블록을 찾으면 각 레코드는 키 값 순으로 정렬되어있고 또한 테이블 레코드를 가진 주소값, 즉 **ROWID**를 가진다. 만약 인덱스 키 값이 같을 경우에는 ROWID로 정렬한다.(키,rowid 순으로 정렬) 

이러한 구조로 우리는 적은 탐색으로 소량의 데이터의 ROWID를 찾을 수 있다. ROWID를 얻기 위한 이유는 ROWID의 구조를 보면 알 수 있다.

ROWID = 데이터 블록 주소(DBA) + 로우 번호
DBA = 데이터 파일 번호 + 블록 번호
블록 번호 = 데이터파일 내에서 부여한 상대적 순번
로우 번호 = 블록 내 순번

**\* ROWID = 데이터 파일 번호 + 데이터파일 내에서 부여한 상대적 순번 + 블록 내 순번** 
즉 ROWID를 이용하면 테이블 레코드로 정확히 찾아갈 수 있다.

인덱스에는 수직적 탐색과 수평적 탐색이 존재한다. 두 가지를 알아야 인덱스 구조를 더 잘 이해할 수 있다.

### 3. 인덱스 수직적 탐색
인덱스 수직적 탐색이란 정렬된 레코드에 만족하는 첫번째 레코드를 찾는 과정이다. 즉 **인덱스 스캔 시작지점을 찾는 과정**이다
수직적 탐색은 루트에서 시작한다. 브랜치 블록은 하위블록에 대한 주소값을 갖는다. bTree구조를 생각하면 쉽게 이해될 것이다. 이런식으로 조건에 맞게 리프블록쪽으로 향하면 인덱스 범위안에 첫번째 값의 위치를 빠르게 찾을 수 있을 것이다. 

### 4. 인덱스 수평적 탐색
인덱스 수평적 탐색은 인데스 범위의 첫번째 만족하는 값의 위치를 수직적 탐색을 통해 알아낸 후 시행하는 과정으로 **데이터를 찾는 과정**이다. 찾고자하는 데이터가 나올때까지 리프블록에서 수평적으로 스캔을 한다. 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 가져 쉽게 이동할 수 있을 것이다. 

인덱스를 수평적탐색하는 이유
첫번째, 조건절에 만족하는 데이터를 모두 찾기 위해
두번째. RowID를 얻기위해
필요한 컬럼을 인덱스가 모두 갖고 있어 인데스만 스캔하고도 끝날 수도 있지만, 일반적으로 인데스 스캔 후 테이블도 액세스한다. 이때 테이블 액세스할 때 RowID가 필요하다.

### 5. 결합 인덱스 구조와 탐색
두개 이상 컬럼을 결합해서 만드는 인덱스도 존재한다. 한개의 컬럼을 가지고 비교할 때와 같은 처리방법을 가진다. 다만 알아둬야할 것은 예를 들어 [고객명+성별]로 하든 [성별+고객명]으로하든 읽는 인덱스 블록 개수가 똑같다는 사실이다.
\+ 이 사실은 굉장히 중요하다. 책에서는 이 예제를 들면서 인터넷에 잘못된 정보로 많이 글이 써져있다고하니 다들 참고해서 정확한 사실로 알고있자

여기서 의문이 생길 수 있는 지점이 다른 데이터를 찾을 때 읽는 블록의 개수가 고정적일까? 각 리프 블록이 루트에 비해 깊거나 얕으면 읽는 블록의 개수는 고정적이지않을 것이다. 하지만 이것은 B(Balanced)Tree의 구조를 보면알 수 있다.  B*Tree B+Tree 모두 BTree에서 파생되어있다. 물론 각 구조에서 어떤식으로 Balanced를 지키는지 과정은 약간씩 다를 수 있으나 큰틀에서 보면 BTree는 삭제나 삽입이 일어날 때 마다 Balanced를 지키기위해 하나의 블록안에 Key의 갯수를 센다. 그리고 KEY가 많으면 분열이 일어나고 적다면 합병이 일어날 수 있다. 인터넷에 BTree 시뮬레이션이라고 치면 대략적으로 어떻게 동작하는지 알 수 있다.